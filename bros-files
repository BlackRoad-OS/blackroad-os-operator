#!/bin/bash
# File operations across repos

CACHE_FILE="$HOME/.blackroad-cache/repos.json"
LOCAL_DIR="${BLACKROAD_LOCAL_DIR:-$HOME/blackroad-repos}"

# Colors
CYAN='\033[0;36m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
MAGENTA='\033[0;35m'
BLUE='\033[0;34m'
NC='\033[0m'
BOLD='\033[1m'

show_header() {
    echo -e "${CYAN}${BOLD}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
    echo -e "${CYAN}${BOLD}â•‘          BLACKROAD FILE OPERATIONS                                 â•‘${NC}"
    echo -e "${CYAN}${BOLD}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo ""
}

# Find files by name
find_files() {
    local filename="$1"
    local pattern="${2:-.}"

    show_header
    echo -e "${GREEN}ðŸ” Finding: $filename${NC}"
    echo ""

    local repos=$(cat "$CACHE_FILE")
    local matches=$(echo "$repos" | jq -r --arg p "$pattern" '.[] | select(.name | ascii_downcase | contains($p | ascii_downcase)) | .name')

    local found=0

    echo "$matches" | while read -r name; do
        if [ -d "$LOCAL_DIR/$name" ]; then
            local files=$(find "$LOCAL_DIR/$name" -name "$filename" -type f 2>/dev/null)

            if [ -n "$files" ]; then
                echo -e "${CYAN}${BOLD}$name:${NC}"
                echo "$files" | while read -r file; do
                    local rel_path=${file#$LOCAL_DIR/$name/}
                    local size=$(du -h "$file" | cut -f1)
                    echo -e "  ${GREEN}âœ“${NC} $rel_path ($size)"
                    ((found++))
                done
                echo ""
            fi
        fi
    done

    echo -e "${BLUE}Total files found: $found${NC}"
}

# Search file contents
grep_files() {
    local search_term="$1"
    local file_pattern="${2:-*}"
    local repo_pattern="${3:-.}"

    show_header
    echo -e "${GREEN}ðŸ”Ž Searching for: '$search_term'${NC}"
    echo -e "${YELLOW}In files: $file_pattern${NC}"
    echo ""

    local repos=$(cat "$CACHE_FILE")
    local matches=$(echo "$repos" | jq -r --arg p "$repo_pattern" '.[] | select(.name | ascii_downcase | contains($p | ascii_downcase)) | .name')

    echo "$matches" | while read -r name; do
        if [ -d "$LOCAL_DIR/$name" ]; then
            local results=$(grep -r "$search_term" "$LOCAL_DIR/$name" --include="$file_pattern" -n 2>/dev/null)

            if [ -n "$results" ]; then
                echo -e "${CYAN}${BOLD}$name:${NC}"
                echo "$results" | while IFS=: read -r file line content; do
                    local rel_path=${file#$LOCAL_DIR/$name/}
                    echo -e "  ${GREEN}$rel_path:$line${NC}"
                    echo -e "    ${YELLOW}$content${NC}"
                done | head -10
                echo ""
            fi
        fi
    done
}

# Copy file to multiple repos
copy_file() {
    local source_file="$1"
    local dest_path="$2"
    local pattern="${3:-.}"

    show_header
    echo -e "${GREEN}ðŸ“‹ Copying File${NC}"
    echo -e "${YELLOW}From: $source_file${NC}"
    echo -e "${YELLOW}To: $dest_path${NC}"
    echo ""

    if [ ! -f "$source_file" ]; then
        echo -e "${RED}Source file not found: $source_file${NC}"
        return 1
    fi

    local repos=$(cat "$CACHE_FILE")
    local matches=$(echo "$repos" | jq -r --arg p "$pattern" '.[] | select(.name | ascii_downcase | contains($p | ascii_downcase)) | .name')

    echo -e "${CYAN}Copying to:${NC}"
    echo "$matches" | while read -r name; do
        echo "  â†’ $name"
    done

    echo ""
    echo -e "${YELLOW}Copy to all? (y/N)${NC}"
    read -r confirm

    if [[ "$confirm" =~ ^[Yy]$ ]]; then
        echo "$matches" | while read -r name; do
            if [ -d "$LOCAL_DIR/$name" ]; then
                local full_dest="$LOCAL_DIR/$name/$dest_path"
                local dest_dir=$(dirname "$full_dest")

                echo -e "${CYAN}$name:${NC}"

                # Create directory if needed
                mkdir -p "$dest_dir"

                # Copy file
                if cp "$source_file" "$full_dest"; then
                    echo -e "  ${GREEN}âœ“ Copied${NC}"
                else
                    echo -e "  ${RED}âœ— Failed${NC}"
                fi
            fi
        done

        echo ""
        echo -e "${GREEN}âœ“ Copy complete${NC}"
    fi
}

# Delete file from repos
delete_file() {
    local file_path="$1"
    local pattern="${2:-.}"

    show_header
    echo -e "${RED}ðŸ—‘ï¸  Deleting: $file_path${NC}"
    echo ""

    local repos=$(cat "$CACHE_FILE")
    local matches=$(echo "$repos" | jq -r --arg p "$pattern" '.[] | select(.name | ascii_downcase | contains($p | ascii_downcase)) | .name')

    local found=0

    # Show files to be deleted
    echo -e "${YELLOW}Files to be deleted:${NC}"
    echo "$matches" | while read -r name; do
        if [ -f "$LOCAL_DIR/$name/$file_path" ]; then
            echo -e "  ${RED}âœ—${NC} $name/$file_path"
            ((found++))
        fi
    done

    if [ $found -eq 0 ]; then
        echo -e "${YELLOW}No files found matching: $file_path${NC}"
        return
    fi

    echo ""
    echo -e "${RED}${BOLD}This will permanently delete these files!${NC}"
    echo -e "${YELLOW}Continue? (y/N)${NC}"
    read -r confirm

    if [[ "$confirm" =~ ^[Yy]$ ]]; then
        echo "$matches" | while read -r name; do
            if [ -f "$LOCAL_DIR/$name/$file_path" ]; then
                echo -e "${CYAN}$name:${NC}"

                if rm "$LOCAL_DIR/$name/$file_path"; then
                    echo -e "  ${GREEN}âœ“ Deleted${NC}"
                else
                    echo -e "  ${RED}âœ— Failed${NC}"
                fi
            fi
        done

        echo ""
        echo -e "${GREEN}âœ“ Deletion complete${NC}"
    fi
}

# Replace text in files
replace_text() {
    local search="$1"
    local replace="$2"
    local file_pattern="${3:-*}"
    local repo_pattern="${4:-.}"

    show_header
    echo -e "${GREEN}ðŸ”„ Replace Text${NC}"
    echo -e "${YELLOW}Search: '$search'${NC}"
    echo -e "${YELLOW}Replace: '$replace'${NC}"
    echo -e "${YELLOW}In files: $file_pattern${NC}"
    echo ""

    local repos=$(cat "$CACHE_FILE")
    local matches=$(echo "$repos" | jq -r --arg p "$repo_pattern" '.[] | select(.name | ascii_downcase | contains($p | ascii_downcase)) | .name')

    # Preview changes
    echo -e "${CYAN}Preview (first 10 occurrences):${NC}"
    local preview_count=0

    echo "$matches" | while read -r name; do
        if [ -d "$LOCAL_DIR/$name" ]; then
            grep -r "$search" "$LOCAL_DIR/$name" --include="$file_pattern" -n 2>/dev/null | while IFS=: read -r file line content; do
                if [ $preview_count -lt 10 ]; then
                    local rel_path=${file#$LOCAL_DIR/$name/}
                    echo -e "  ${GREEN}$name/$rel_path:$line${NC}"
                    echo -e "    ${RED}- $content${NC}"
                    echo -e "    ${GREEN}+ ${content//$search/$replace}${NC}"
                    ((preview_count++))
                fi
            done
        fi
    done

    echo ""
    echo -e "${YELLOW}Apply changes? (y/N)${NC}"
    read -r confirm

    if [[ "$confirm" =~ ^[Yy]$ ]]; then
        local changed=0

        echo "$matches" | while read -r name; do
            if [ -d "$LOCAL_DIR/$name" ]; then
                # Find and replace in files
                find "$LOCAL_DIR/$name" -name "$file_pattern" -type f -exec grep -l "$search" {} \; 2>/dev/null | while read -r file; do
                    sed -i.bak "s/$search/$replace/g" "$file"
                    rm "${file}.bak"

                    local rel_path=${file#$LOCAL_DIR/$name/}
                    echo -e "${GREEN}âœ“${NC} $name/$rel_path"
                    ((changed++))
                done
            fi
        done

        echo ""
        echo -e "${GREEN}âœ“ Replaced in $changed files${NC}"
    fi
}

# List common files
list_common() {
    local pattern="${1:-.}"

    show_header
    echo -e "${GREEN}ðŸ“„ Common Files${NC}"
    echo ""

    local repos=$(cat "$CACHE_FILE")
    local matches=$(echo "$repos" | jq -r --arg p "$pattern" '.[] | select(.name | ascii_downcase | contains($p | ascii_downcase)) | .name')

    declare -A file_counts

    # Scan for common files
    echo "$matches" | while read -r name; do
        if [ -d "$LOCAL_DIR/$name" ]; then
            find "$LOCAL_DIR/$name" -maxdepth 1 -type f -name ".*" -o -maxdepth 1 -type f ! -name ".*" 2>/dev/null | while read -r file; do
                local basename=$(basename "$file")
                # Track occurrence (won't persist due to subshell)
                :
            done
        fi
    done

    # Common config files to check
    local common_files=("package.json" "README.md" ".gitignore" "Dockerfile" "docker-compose.yml" "tsconfig.json" "requirements.txt" ".env.example" "Makefile" "LICENSE")

    for filename in "${common_files[@]}"; do
        local count=0
        echo "$matches" | while read -r name; do
            if [ -f "$LOCAL_DIR/$name/$filename" ]; then
                ((count++))
            fi
        done

        if [ $count -gt 0 ]; then
            echo -e "  ${GREEN}$filename:${NC} $count repos"
        fi
    done
}

# Check file sizes
file_sizes() {
    local file_pattern="$1"
    local repo_pattern="${2:-.}"

    show_header
    echo -e "${GREEN}ðŸ“Š File Sizes${NC}"
    echo -e "${YELLOW}Pattern: $file_pattern${NC}"
    echo ""

    local repos=$(cat "$CACHE_FILE")
    local matches=$(echo "$repos" | jq -r --arg p "$repo_pattern" '.[] | select(.name | ascii_downcase | contains($p | ascii_downcase)) | .name')

    local files_info=()

    echo "$matches" | while read -r name; do
        if [ -d "$LOCAL_DIR/$name" ]; then
            find "$LOCAL_DIR/$name" -name "$file_pattern" -type f -exec du -h {} \; 2>/dev/null | while read -r size file; do
                local rel_path=${file#$LOCAL_DIR/$name/}
                echo -e "  $size\t$name/$rel_path"
            done
        fi
    done | sort -hr | head -20

    echo ""
    echo -e "${BLUE}(Showing top 20 largest files)${NC}"
}

# Main
main() {
    if [ ! -f "$CACHE_FILE" ]; then
        echo -e "${RED}Error: Cache not found. Run 'bros refresh' first.${NC}"
        exit 1
    fi

    case "${1:-help}" in
        find|search)
            find_files "$2" "$3"
            ;;
        grep|content)
            grep_files "$2" "$3" "$4"
            ;;
        copy|cp)
            copy_file "$2" "$3" "$4"
            ;;
        delete|rm)
            delete_file "$2" "$3"
            ;;
        replace|sed)
            replace_text "$2" "$3" "$4" "$5"
            ;;
        common)
            list_common "$2"
            ;;
        sizes)
            file_sizes "$2" "$3"
            ;;
        *)
            echo "Usage: bros-files <command> [options]"
            echo ""
            echo "Commands:"
            echo "  find <filename> [pattern]             Find files by name"
            echo "  grep <term> [file-pattern] [pattern]  Search file contents"
            echo "  copy <source> <dest> [pattern]        Copy file to repos"
            echo "  delete <path> [pattern]               Delete file from repos"
            echo "  replace <search> <replace> [file] [pattern]  Replace text"
            echo "  common [pattern]                      List common files"
            echo "  sizes <file-pattern> [pattern]        Show file sizes"
            echo ""
            echo "Examples:"
            echo "  bros-files find package.json"
            echo "  bros-files grep 'TODO' '*.ts' dashboard"
            echo "  bros-files copy .prettierrc .prettierrc dashboard"
            echo "  bros-files replace 'old-api' 'new-api' '*.ts'"
            echo "  bros-files common agent"
            echo "  bros-files sizes 'node_modules'"
            echo ""
            echo "Note: Repos must be cloned locally (use bros-sync clone)"
            ;;
    esac
}

main "$@"
