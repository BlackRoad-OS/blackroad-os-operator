#!/bin/bash
# Secret and environment variable management

CACHE_FILE="$HOME/.blackroad-cache/repos.json"

# Colors
CYAN='\033[0;36m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
MAGENTA='\033[0;35m'
BLUE='\033[0;34m'
NC='\033[0m'
BOLD='\033[1m'

show_header() {
    echo -e "${CYAN}${BOLD}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó${NC}"
    echo -e "${CYAN}${BOLD}‚ïë          BLACKROAD SECRETS MANAGEMENT                              ‚ïë${NC}"
    echo -e "${CYAN}${BOLD}‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù${NC}"
    echo ""
}

# List secrets in repos
list_secrets() {
    local pattern="${1:-.}"

    show_header
    echo -e "${GREEN}üîê Repository Secrets${NC}"
    echo ""

    local repos=$(cat "$CACHE_FILE")
    local matches=$(echo "$repos" | jq -r --arg p "$pattern" '.[] | select(.name | ascii_downcase | contains($p | ascii_downcase)) | .name')

    if [ -z "$matches" ]; then
        echo -e "${RED}No repos match: $pattern${NC}"
        return 1
    fi

    echo "$matches" | while read -r name; do
        local owner=$(echo "$repos" | jq -r --arg n "$name" '.[] | select(.name == $n) | .url | split("/")[-2]')

        echo -e "${CYAN}${BOLD}$owner/$name:${NC}"
        local secrets=$(gh secret list --repo "$owner/$name" 2>/dev/null)

        if [ -n "$secrets" ]; then
            echo "$secrets" | tail -n +2 | while read -r line; do
                local secret_name=$(echo "$line" | awk '{print $1}')
                local updated=$(echo "$line" | awk '{print $2, $3, $4}')
                echo -e "  ${GREEN}‚úì${NC} $secret_name (Updated: $updated)"
            done
        else
            echo -e "  ${YELLOW}(no secrets)${NC}"
        fi
        echo ""
    done
}

# Set secret in repos
set_secret() {
    local secret_name="$1"
    local secret_value="$2"
    local pattern="${3:-.}"

    show_header
    echo -e "${GREEN}üîí Setting Secret: $secret_name${NC}"
    echo ""

    if [ -z "$secret_name" ] || [ -z "$secret_value" ]; then
        echo -e "${RED}Error: Secret name and value required${NC}"
        echo "Usage: bros-secrets set <name> <value> [pattern]"
        return 1
    fi

    local repos=$(cat "$CACHE_FILE")
    local matches=$(echo "$repos" | jq -r --arg p "$pattern" '.[] | select(.name | ascii_downcase | contains($p | ascii_downcase)) | .name')

    if [ -z "$matches" ]; then
        echo -e "${RED}No repos match: $pattern${NC}"
        return 1
    fi

    echo -e "${CYAN}Setting secret in:${NC}"
    echo "$matches" | while read -r name; do
        echo "  ‚Üí $name"
    done

    echo ""
    echo -e "${YELLOW}Set secret in all? (y/N)${NC}"
    read -r confirm

    if [[ "$confirm" =~ ^[Yy]$ ]]; then
        echo "$matches" | while read -r name; do
            local owner=$(echo "$repos" | jq -r --arg n "$name" '.[] | select(.name == $n) | .url | split("/")[-2]')

            echo -e "${CYAN}$owner/$name:${NC}"
            if echo "$secret_value" | gh secret set "$secret_name" --repo "$owner/$name" 2>/dev/null; then
                echo -e "  ${GREEN}‚úì Secret set${NC}"
            else
                echo -e "  ${RED}‚úó Failed${NC}"
            fi
        done

        echo ""
        echo -e "${GREEN}‚úì Secret setting complete${NC}"
    fi
}

# Remove secret from repos
remove_secret() {
    local secret_name="$1"
    local pattern="${2:-.}"

    show_header
    echo -e "${RED}üóëÔ∏è  Removing Secret: $secret_name${NC}"
    echo ""

    if [ -z "$secret_name" ]; then
        echo -e "${RED}Error: Secret name required${NC}"
        echo "Usage: bros-secrets remove <name> [pattern]"
        return 1
    fi

    local repos=$(cat "$CACHE_FILE")
    local matches=$(echo "$repos" | jq -r --arg p "$pattern" '.[] | select(.name | ascii_downcase | contains($p | ascii_downcase)) | .name')

    if [ -z "$matches" ]; then
        echo -e "${RED}No repos match: $pattern${NC}"
        return 1
    fi

    echo -e "${CYAN}Removing secret from:${NC}"
    echo "$matches" | while read -r name; do
        echo "  ‚Üí $name"
    done

    echo ""
    echo -e "${RED}${BOLD}This will permanently delete the secret!${NC}"
    echo -e "${YELLOW}Continue? (y/N)${NC}"
    read -r confirm

    if [[ "$confirm" =~ ^[Yy]$ ]]; then
        echo "$matches" | while read -r name; do
            local owner=$(echo "$repos" | jq -r --arg n "$name" '.[] | select(.name == $n) | .url | split("/")[-2]')

            echo -e "${CYAN}$owner/$name:${NC}"
            if gh secret remove "$secret_name" --repo "$owner/$name" 2>/dev/null; then
                echo -e "  ${GREEN}‚úì Secret removed${NC}"
            else
                echo -e "  ${YELLOW}Secret may not exist${NC}"
            fi
        done

        echo ""
        echo -e "${GREEN}‚úì Secret removal complete${NC}"
    fi
}

# Copy secrets from one repo to others
copy_secrets() {
    local source_repo="$1"
    local pattern="${2:-.}"

    show_header
    echo -e "${GREEN}üìã Copying Secrets from $source_repo${NC}"
    echo ""

    if [ -z "$source_repo" ]; then
        echo -e "${RED}Error: Source repo required${NC}"
        echo "Usage: bros-secrets copy <source-repo> [target-pattern]"
        return 1
    fi

    local repos=$(cat "$CACHE_FILE")
    local source_owner=$(echo "$repos" | jq -r --arg n "$source_repo" '.[] | select(.name == $n) | .url | split("/")[-2]')

    if [ -z "$source_owner" ]; then
        echo -e "${RED}Source repo not found: $source_repo${NC}"
        return 1
    fi

    # Get secret names from source
    echo -e "${CYAN}Fetching secrets from $source_owner/$source_repo...${NC}"
    local secret_names=$(gh secret list --repo "$source_owner/$source_repo" 2>/dev/null | tail -n +2 | awk '{print $1}')

    if [ -z "$secret_names" ]; then
        echo -e "${YELLOW}No secrets found in source repo${NC}"
        return 1
    fi

    echo -e "${GREEN}Found secrets:${NC}"
    echo "$secret_names" | while read -r secret; do
        echo "  ‚Üí $secret"
    done

    echo ""
    echo -e "${RED}Note: You'll need to provide values (secrets can't be read)${NC}"
    echo -e "${YELLOW}Continue to set these secrets in target repos? (y/N)${NC}"
    read -r confirm

    if [[ "$confirm" =~ ^[Yy]$ ]]; then
        local matches=$(echo "$repos" | jq -r --arg p "$pattern" --arg s "$source_repo" '.[] | select(.name | ascii_downcase | contains($p | ascii_downcase)) | select(.name != $s) | .name')

        echo "$secret_names" | while read -r secret; do
            echo ""
            echo -e "${CYAN}Enter value for $secret (or press Enter to skip):${NC}"
            read -rs value

            if [ -n "$value" ]; then
                echo "$matches" | while read -r name; do
                    local owner=$(echo "$repos" | jq -r --arg n "$name" '.[] | select(.name == $n) | .url | split("/")[-2]')
                    echo "$value" | gh secret set "$secret" --repo "$owner/$name" 2>/dev/null
                done
                echo -e "${GREEN}‚úì $secret set in target repos${NC}"
            fi
        done
    fi
}

# Check for common secrets across repos
audit_secrets() {
    local pattern="${1:-.}"

    show_header
    echo -e "${GREEN}üîç Secret Audit${NC}"
    echo ""

    local repos=$(cat "$CACHE_FILE")
    local matches=$(echo "$repos" | jq -r --arg p "$pattern" '.[] | select(.name | ascii_downcase | contains($p | ascii_downcase)) | .name')

    declare -A secret_counts

    echo -e "${CYAN}Scanning repos for secrets...${NC}"
    echo ""

    echo "$matches" | while read -r name; do
        local owner=$(echo "$repos" | jq -r --arg n "$name" '.[] | select(.name == $n) | .url | split("/")[-2]')
        local secrets=$(gh secret list --repo "$owner/$name" 2>/dev/null | tail -n +2 | awk '{print $1}')

        if [ -n "$secrets" ]; then
            echo "$secrets" | while read -r secret; do
                # This won't persist due to subshell, but shows the pattern
                count=${secret_counts[$secret]:-0}
                ((count++))
                secret_counts[$secret]=$count
            done
        fi
    done

    # Show common secrets
    echo -e "${GREEN}${BOLD}Common Secrets:${NC}"
    for secret in "${!secret_counts[@]}"; do
        echo "  $secret: ${secret_counts[$secret]} repos"
    done
}

# Sync secrets from a template file
sync_from_file() {
    local env_file="$1"
    local pattern="${2:-.}"

    show_header
    echo -e "${GREEN}üìÅ Syncing Secrets from File${NC}"
    echo ""

    if [ ! -f "$env_file" ]; then
        echo -e "${RED}File not found: $env_file${NC}"
        return 1
    fi

    local repos=$(cat "$CACHE_FILE")
    local matches=$(echo "$repos" | jq -r --arg p "$pattern" '.[] | select(.name | ascii_downcase | contains($p | ascii_downcase)) | .name')

    echo -e "${CYAN}Reading secrets from $env_file...${NC}"
    echo ""

    # Parse .env file format
    while IFS='=' read -r key value; do
        # Skip comments and empty lines
        [[ "$key" =~ ^#.*$ ]] && continue
        [[ -z "$key" ]] && continue

        # Remove quotes from value
        value=$(echo "$value" | sed -e 's/^"//' -e 's/"$//' -e "s/^'//" -e "s/'$//")

        echo -e "${YELLOW}Setting $key...${NC}"

        echo "$matches" | while read -r name; do
            local owner=$(echo "$repos" | jq -r --arg n "$name" '.[] | select(.name == $n) | .url | split("/")[-2]')
            echo "$value" | gh secret set "$key" --repo "$owner/$name" 2>/dev/null
        done

        echo -e "${GREEN}‚úì $key set${NC}"
    done < "$env_file"

    echo ""
    echo -e "${GREEN}‚úì Secrets synced from file${NC}"
}

# Main
main() {
    if [ ! -f "$CACHE_FILE" ]; then
        echo -e "${RED}Error: Cache not found. Run 'bros refresh' first.${NC}"
        exit 1
    fi

    case "${1:-help}" in
        list|ls)
            list_secrets "$2"
            ;;
        set)
            set_secret "$2" "$3" "$4"
            ;;
        remove|rm)
            remove_secret "$2" "$3"
            ;;
        copy)
            copy_secrets "$2" "$3"
            ;;
        audit)
            audit_secrets "$2"
            ;;
        sync-file|sync)
            sync_from_file "$2" "$3"
            ;;
        *)
            echo "Usage: bros-secrets <command> [options]"
            echo ""
            echo "Commands:"
            echo "  list [pattern]                List secrets in repos"
            echo "  set <name> <value> [pattern]  Set secret in repos"
            echo "  remove <name> [pattern]       Remove secret from repos"
            echo "  copy <source> [pattern]       Copy secret names from source to targets"
            echo "  audit [pattern]               Audit secrets across repos"
            echo "  sync <file> [pattern]         Sync secrets from .env file"
            echo ""
            echo "Examples:"
            echo "  bros-secrets list dashboard"
            echo "  bros-secrets set API_KEY 'sk-xxx' agent"
            echo "  bros-secrets copy blackroad-os-operator dashboard"
            echo "  bros-secrets sync .env.prod dashboard"
            echo ""
            echo "Security notes:"
            echo "  - Secrets are stored encrypted in GitHub"
            echo "  - Secret values cannot be read, only updated"
            echo "  - Use gh CLI authentication"
            ;;
    esac
}

main "$@"
